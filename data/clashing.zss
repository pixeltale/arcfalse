# Universal Clashing System by Phantom.of.the.Server
# For Ikemen GO November 2024 build and above

# See the readme for installation instructions


#===============================================================================
# Configuration
#===============================================================================

[Function F_PotS_Clashing_Config()]

mapset{map: "_pots_clashing_cfg_prioritycheck"; value: 0}	# Clash only if both attacks have the same priority
mapset{map: "_pots_clashing_cfg_clsn2check"; value: 1}		# Clash only if the hurtboxes are not hit
mapset{map: "_pots_clashing_cfg_pause"; value: 18}			# Duration of pause upon a clash
mapset{map: "_pots_clashing_cfg_zoom"; value: 1.1}			# Amount to zoom during a clash
mapset{map: "_pots_clashing_cfg_simul"; value: 1}			# Allow clashes during simul mode



#===============================================================================
# Negative states
#===============================================================================

[Statedef +1]

ignorehitpause if !ishelper {

	# Run config
	if roundstate = 0 && time = 0 {
		call F_PotS_Clashing_Config();
	}

	# Check attack attributes for both players
	if movetype = A || p2movetype = A {
		let p1_attr_normal = stateno = [200, 999] || hitdefattr = SCA, NA, NT, NP;
		let p2_attr_normal = p2stateno = [200, 999] || p2, hitdefattr = SCA, NA, NT, NP;
		let p1_attr_special = stateno = [1000, 2999] || hitdefattr = SCA, SA, ST, SP;
		let p2_attr_special = p2stateno = [1000, 2999] || p2, hitdefattr = SCA, SA, ST, SP;
		let p1_attr_super = stateno = [3000, 4999] || hitdefattr = SCA, HA, HT, HP;
		let p2_attr_super = p2stateno = [3000, 4999] || p2, hitdefattr = SCA, HA, HT, HP;
	}

	if roundstate = 2
	&& ID > p2, ID # Run code from last player that is processed
	&& ID = p2, p2, ID # Ensure both players are referring to each other
	&& movetype = A
	&& p2movetype = A
	&& hitdefattr = SCA, AA
	&& p2, hitdefattr = SCA, AA
	&& reversaldefattr != SCA, AA, AP, AT
	&& p2, reversaldefattr != SCA, AA, AP, AT
	# Check simul mode
	&& (map(_pots_clashing_cfg_simul) != 0 || (teammode != Simul && p2, teammode != Simul))
	# Check priority
	&& (map(_pots_clashing_cfg_prioritycheck) = 0 || (hitdefvar(priority) = p2, hitdefvar(priority))) {

		# Check if the chars can hit each other
		if cond(hitdefattr = S, NA, p2, hitbyattr(S, NA), 1)
		&& cond(hitdefattr = C, NA, p2, hitbyattr(C, NA), 1)
		&& cond(hitdefattr = A, NA, p2, hitbyattr(A, NA), 1)
		&& cond(hitdefattr = S, SA, p2, hitbyattr(S, SA), 1)
		&& cond(hitdefattr = C, SA, p2, hitbyattr(C, SA), 1)
		&& cond(hitdefattr = A, SA, p2, hitbyattr(A, SA), 1)
		&& cond(hitdefattr = S, HA, p2, hitbyattr(S, HA), 1)
		&& cond(hitdefattr = C, HA, p2, hitbyattr(C, HA), 1)
		&& cond(hitdefattr = A, HA, p2, hitbyattr(A, HA), 1)
		&& cond(p2, hitdefattr = S, NA, hitbyattr(S, NA), 1)
		&& cond(p2, hitdefattr = C, NA, hitbyattr(C, NA), 1)
		&& cond(p2, hitdefattr = A, NA, hitbyattr(A, NA), 1)
		&& cond(p2, hitdefattr = S, SA, hitbyattr(S, SA), 1)
		&& cond(p2, hitdefattr = C, SA, hitbyattr(C, SA), 1)
		&& cond(p2, hitdefattr = A, SA, hitbyattr(A, SA), 1)
		&& cond(p2, hitdefattr = S, HA, hitbyattr(S, HA), 1)
		&& cond(p2, hitdefattr = C, HA, hitbyattr(C, HA), 1)
		&& cond(p2, hitdefattr = A, HA, hitbyattr(A, HA), 1) {

			# Collision detection
			# Using ClsnOverlap will not account for the velocity of the second player that is processed
			# To get around it, one should run the code from a third entity that is processed last, such as a helper
			if clsnoverlap(clsn1, p2, ID, clsn1)
			&& cond(map(_pots_clashing_cfg_clsn2check), clsnoverlap(clsn1, p2, ID, clsn2) = 0 && p2, clsnoverlap(clsn1, ID, clsn2) = 0, 1) {

				# Disable Hitdefs
				# Some characters will get around this but it should work most of the time
				modifyHitdef{attr: ; hitflag: ;}
				modifyHitdef{attr: ; hitflag: ; redirectID: p2, ID}

				# Lifebar messages
				lifebaraction{text: "Clash"; top: 1}
				lifebaraction{text: "Clash"; top: 1; redirectID: p2, ID}

				# Pause
				pause{time: map(_pots_clashing_cfg_pause); pausebg: 0}

				# Screen flash
				bgpalfx{
					time: map(_pots_clashing_cfg_pause);
					add: 128, 128, 128;
					sinadd: -128, -128, -128, 120;
				}

				# Screen shake
				envshake{
					time: 20;
					ampl: ifelse((gametime % 2), -4, 4);
					freq: 180;
					mul: 0.67;
				}

				# Zoom
				if map(_pots_clashing_cfg_zoom) != 1.0 {
					zoom{
						scale: map(_pots_clashing_cfg_zoom);
						time: 6;
						pos: 0, 0;
						lag: 0.618;
						stagebound: 1;
						camerabound: 1;
					}
				}

				# Sound
				# You can add your own sounds here by adding them to common.snd
				playsnd{
					value: F 6, 0;
					volumescale: 100;
					freqmul: 1.00;
				}
				playsnd{
					value: F 5, 3;
					volumescale: 100;
					freqmul: 2.00;
				}
				playsnd{
					value: F 7, 2;
					volumescale: 100;
					freqmul: 2.00;
				}

				# Find spark position
				# The Y component might be easier with HitDefVar(sparky)

				# Player 1 (Me)
				# Assume there's only one Clsn1 first
				let sparkback1 = clsnVar(clsn1, 0, back);
				let sparkfront1 = clsnVar(clsn1, 0, front);
				let sparktop1 = clsnVar(clsn1, 0, top);
				let sparkbot1 = clsnVar(clsn1, 0, bottom);

				# If more, find edges
				if animFrame(numClsn1) > 1 {
					for i = 1; animFrame(numClsn1); 1 {
						if clsnVar(clsn1, $i, back) < $sparkback1 {
							let sparkback1 = clsnVar(clsn1, $i, back);
						}
						if clsnVar(clsn1, $i, front) > $sparkfront1 {
							let sparkfront1 = clsnVar(clsn1, $i, front);
						}
						if clsnVar(clsn1, $i, top) < $sparktop1 {
							let sparktop1 = clsnVar(clsn1, $i, top);
						}
						if clsnVar(clsn1, $i, bottom) > $sparkbot1 {
							let sparkbot1 = clsnVar(clsn1, $i, bottom);
						}
					}
				}

				# Player 2 (Them)
				# Assume there's only one Clsn1 first
				let sparkback2 = p2, clsnVar(clsn1, 0, back);
				let sparkfront2 = p2, clsnVar(clsn1, 0, front);
				let sparktop2 = p2, clsnVar(clsn1, 0, top);
				let sparkbot2 = p2, clsnVar(clsn1, 0, bottom);

				# If more, find edges
				if p2, animFrame(numClsn1) > 1 {
					for i = 1; p2, animFrame(numClsn1); 1 {
						if p2, clsnVar(clsn1, $i, back) < $sparkback2 {
							let sparkback2 = p2, clsnVar(clsn1, $i, back);
						}
						if p2, clsnVar(clsn1, $i, front) > $sparkfront2 {
							let sparkfront2 = p2, clsnVar(clsn1, $i, front);
						}
						if p2, clsnVar(clsn1, $i, top) < $sparktop2 {
							let sparktop2 = p2, clsnVar(clsn1, $i, top);
						}
						if p2, clsnVar(clsn1, $i, bottom) > $sparkbot2 {
							let sparkbot2 = p2, clsnVar(clsn1, $i, bottom);
						}
					}
				}

				# Account for facing
				let sparkback1 = $sparkback1 * facing;
				let sparkfront1 = $sparkfront1 * facing;
				let sparkback2 = $sparkback2 * p2, facing;
				let sparkfront2 = $sparkfront2 * p2, facing;

				# Calculate middle point
				let sparkx1 = screenpos x + ifelse(p2dist x < 0, $sparkback1, $sparkfront1);
				let sparky1 = screenpos y + ifelse(p2dist y < 0, $sparktop1, $sparkbot1);

				let sparkx2 = p2, screenpos x + ifelse(p2, p2dist x <= 0, $sparkback2, $sparkfront2);
				let sparky2 = p2, screenpos y + ifelse(p2, p2dist y <= 0, $sparktop2, $sparkbot2);

				let sparkx = ($sparkx1 + $sparkx2) / 2.0 * camerazoom;
				let sparky = ($sparky1 + $sparky2) / 2.0 * camerazoom;

				# Create sparks
				# You can add your own sparks here by adding them to the fightfx
				explod{
					anim: F 60;
					postype: left;
					pos: $sparkx, $sparky;
					scale: 2.00, 0.67;
					angle: 45;
					facing: 1;
					ontop: 1;
					pausemovetime: -1;
					supermovetime: -1;
					ownpal: 1
				}
				explod{
					anim: F 60;
					postype: left;
					pos: $sparkx, $sparky;
					scale: 2.00, 0.67;
					angle: 45;
					facing: -1;
					ontop: 1;
					pausemovetime: -1;
					supermovetime: -1;
					ownpal: 1
				}

			}
		}
	}
}
